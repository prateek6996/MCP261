# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UlQdOBrwTXSKiIZdt2QFoeU3G2LyxpsL
"""

import numpy as np
from scipy.optimize import linprog

def branch_and_bound(c, A, b, bounds):
    best_obj = float('inf')  # Initialize the best objective value
    best_solution = None  # Initialize the best solution

    def branch(c, A, b, bounds, obj_val, solution):
        nonlocal best_obj, best_solution

        # Solve the LP relaxation
        lp_result = linprog(c, A_ub=A, b_ub=b, bounds=bounds)
        lp_obj_val = lp_result.fun
        lp_solution = lp_result.x

        # Check if the LP relaxation is infeasible or its objective value is worse than the current best
        if lp_result.status == 2 or lp_obj_val >= best_obj:
            return

        # Check if the LP relaxation is an integer solution and update the best solution if necessary
        if np.all(np.floor(lp_solution) == lp_solution):
            best_obj = lp_obj_val
            best_solution = lp_solution
            return

        # Find the index of the variable with the largest fractional part
        frac_idx = np.argmax(lp_solution - np.floor(lp_solution))

        # Create two new subproblems by adding binary constraints to the LP relaxation
        subproblem_1 = (c, np.vstack((A, np.zeros(A.shape[1]))), np.concatenate((b, [np.floor(lp_solution[frac_idx])])))
        subproblem_2 = (c, np.vstack((A, np.zeros(A.shape[1]))), np.concatenate((b, [-np.ceil(lp_solution[frac_idx])])))

        # Update the bounds for the fractional variable in the subproblems
        subproblem_1_bounds = bounds.copy()
        subproblem_1_bounds[frac_idx] = (np.floor(lp_solution[frac_idx]), np.floor(lp_solution[frac_idx]))
        subproblem_2_bounds = bounds.copy()
        subproblem_2_bounds[frac_idx] = (np.ceil(lp_solution[frac_idx]), np.ceil(lp_solution[frac_idx]))

        # Recursively solve the subproblems
        branch(*subproblem_1, subproblem_1_bounds, obj_val=lp_obj_val, solution=lp_solution)
        branch(*subproblem_2, subproblem_2_bounds, obj_val=lp_obj_val, solution=lp_solution)

    # Initial call to the branch and bound algorithm
    branch(c, A, b, bounds, obj_val=None, solution=None)

    return best_obj, best_solution

# Objective function coefficients
c = [-3, -5]

# Coefficient matrix for inequality constraints
A = [[1, 2],
     [3, 2]]

# Right-hand side vector for inequality constraints
b = [6, 12]

# Variable bounds
bounds = [(0, None), (0, None)]

# Solve the MILP problem using branch and bound
best_obj, best_solution = branch_and_bound(c, np.array(A), b, bounds)

# Print the optimal objective value and solution
print("Optimal Objective Value:", -best_obj)  # Multiply by -1 to maximize
print("Optimal Solution:", best_solution)